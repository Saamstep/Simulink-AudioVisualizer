var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":true},"build":"bucket_fft","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"bucket_fft.h\"\n#include \"bucket_fft_private.h\"\n#include \"rtwtypes.h\"\n#include \"limits.h\"\n#include \"rt_nonfinite.h\"\n#include \"MW_raspi_init.h\"\n#include \"MW_Pyserver_control.h\"\n#include \"linuxinitialize.h\"\n#define UNUSED(x)                      x = x\n#define NAMELEN                        16\n\n/* Function prototype declaration*/\nvoid exitFcn(int sig);\nvoid *terminateTask(void *arg);\nvoid *baseRateTask(void *arg);\nvoid *subrateTask(void *arg);\nvolatile boolean_T stopRequested = false;\nvolatile boolean_T runModel = true;\nsem_t stopSem;\nsem_t baserateTaskSem;\nsem_t subrateTaskSem[2];\nint taskId[2];\npthread_t schedulerThread;\npthread_t baseRateThread;\nvoid *threadJoinStatus;\nint terminatingmodel = 0;\npthread_t subRateThread[2];\nint subratePriority[2];\nvoid *subrateTask(void *arg)\n{\n  int tid = *((int *) arg);\n  int subRateId;\n  subRateId = tid + 1;\n  while (runModel) {\n    sem_wait(&subrateTaskSem[tid]);\n    if (terminatingmodel)\n      break;\n\n#ifdef MW_RTOS_DEBUG\n\n    printf(\" -subrate task %d semaphore received\\n\", subRateId);\n\n#endif\n\n    bucket_fft_step(subRateId);\n\n    /* Get model outputs here */\n  }\n\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid *baseRateTask(void *arg)\n{\n  int_T i;\n  runModel = (rtmGetErrorStatus(bucket_fft_M) == (NULL)) && !rtmGetStopRequested\n    (bucket_fft_M);\n  while (runModel) {\n    sem_wait(&baserateTaskSem);\n\n#ifdef MW_RTOS_DEBUG\n\n    printf(\"*base rate task semaphore received\\n\");\n    fflush(stdout);\n\n#endif\n\n    for (i = 1\n         ; i <= 2; i++) {\n      if (rtmStepTask(bucket_fft_M, i)\n          ) {\n        sem_post(&subrateTaskSem[ i - 1\n                 ]);\n      }\n    }\n\n    bucket_fft_step(0);\n\n    /* Get model outputs here */\n    stopRequested = !((rtmGetErrorStatus(bucket_fft_M) == (NULL)) &&\n                      !rtmGetStopRequested(bucket_fft_M));\n  }\n\n  terminateTask(arg);\n  pthread_exit((void *)0);\n  return NULL;\n}\n\nvoid exitFcn(int sig)\n{\n  UNUSED(sig);\n  rtmSetErrorStatus(bucket_fft_M, \"stopping the model\");\n  runModel = 0;\n}\n\nvoid *terminateTask(void *arg)\n{\n  UNUSED(arg);\n  terminatingmodel = 1;\n\n  {\n    int i;\n\n    /* Signal all periodic tasks to complete */\n    for (i=0; i<2; i++) {\n      CHECK_STATUS(sem_post(&subrateTaskSem[i]), 0, \"sem_post\");\n      CHECK_STATUS(sem_destroy(&subrateTaskSem[i]), 0, \"sem_destroy\");\n    }\n\n    /* Wait for all periodic tasks to complete */\n    for (i=0; i<2; i++) {\n      CHECK_STATUS(pthread_join(subRateThread[i], &threadJoinStatus), 0,\n                   \"pthread_join\");\n    }\n\n    runModel = 0;\n  }\n\n  MW_killPyserver();\n  mwRaspiTerminate();\n\n  /* Terminate model */\n  bucket_fft_terminate();\n  sem_post(&stopSem);\n  return NULL;\n}\n\nint main(int argc, char **argv)\n{\n  UNUSED(argc);\n  UNUSED(argv);\n  subratePriority[0] = 39;\n  subratePriority[1] = 38;\n  mwRaspiInit();\n  MW_launchPyserver();\n  rtmSetErrorStatus(bucket_fft_M, 0);\n\n  /* Initialize model */\n  bucket_fft_initialize();\n\n  /* Call RTOS Initialization function */\n  myRTOSInit(0.00018140589569160998, 2);\n\n  /* Wait for stop semaphore */\n  sem_wait(&stopSem);\n\n#if (MW_NUMBER_TIMER_DRIVEN_TASKS > 0)\n\n  {\n    int i;\n    for (i=0; i < MW_NUMBER_TIMER_DRIVEN_TASKS; i++) {\n      CHECK_STATUS(sem_destroy(&timerTaskSem[i]), 0, \"sem_destroy\");\n    }\n  }\n\n#endif\n\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"bucket_fft.c","type":"source","group":"model","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: bucket_fft.c\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"bucket_fft.h\"\n#include \"rtwtypes.h\"\n#include <string.h>\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n\n/* Named constants for Chart: '<Root>/Chart' */\n#define bucket_fft_IN_IDLE             ((uint8_T)1U)\n#define bucket_fft_IN_micMode          ((uint8_T)2U)\n#define bucket_fft_IN_mp3Mode          ((uint8_T)3U)\n\n/* Block signals (default storage) */\nB_bucket_fft_T bucket_fft_B;\n\n/* Block states (default storage) */\nDW_bucket_fft_T bucket_fft_DW;\n\n/* Real-time model */\nstatic RT_MODEL_bucket_fft_T bucket_fft_M_;\nRT_MODEL_bucket_fft_T *const bucket_fft_M = &bucket_fft_M_;\nstatic void rate_monotonic_scheduler(void);\n\n/*\n * Set which subrates need to run this base step (base rate always runs).\n * This function must be called prior to calling the model step function\n * in order to remember which rates need to run this base step.  The\n * buffering of events allows for overlapping preemption.\n */\nvoid bucket_fft_SetEventsForThisBaseStep(boolean_T *eventFlags)\n{\n  /* Task runs when its counter is zero, computed via rtmStepTask macro */\n  eventFlags[1] = ((boolean_T)rtmStepTask(bucket_fft_M, 1));\n  eventFlags[2] = ((boolean_T)rtmStepTask(bucket_fft_M, 2));\n}\n\n/*\n *         This function updates active task flag for each subrate\n *         and rate transition flags for tasks that exchange data.\n *         The function assumes rate-monotonic multitasking scheduler.\n *         The function must be called at model base rate so that\n *         the generated code self-manages all its subrates and rate\n *         transition flags.\n */\nstatic void rate_monotonic_scheduler(void)\n{\n  /* Compute which subrates run during the next base time step.  Subrates\n   * are an integer multiple of the base rate counter.  Therefore, the subtask\n   * counter is reset when it reaches its limit (zero means run).\n   */\n  (bucket_fft_M->Timing.TaskCounters.TID[1])++;\n  if ((bucket_fft_M->Timing.TaskCounters.TID[1]) > 127) {\n                                /* Sample time: [0.023219954648526078s, 0.0s] */\n    bucket_fft_M->Timing.TaskCounters.TID[1] = 0;\n  }\n\n  (bucket_fft_M->Timing.TaskCounters.TID[2])++;\n  if ((bucket_fft_M->Timing.TaskCounters.TID[2]) > 2474) {\n                                 /* Sample time: [0.44897959183673469s, 0.0s] */\n    bucket_fft_M->Timing.TaskCounters.TID[2] = 0;\n  }\n}\n\n/* Model step function for TID0 */\nvoid bucket_fft_step0(void)   /* Sample time: [0.00018140589569160998s, 0.0s] */\n{\n  {                           /* Sample time: [0.00018140589569160998s, 0.0s] */\n    rate_monotonic_scheduler();\n  }\n}\n\n/* Model step function for TID1 */\nvoid bucket_fft_step1(void)     /* Sample time: [0.023219954648526078s, 0.0s] */\n{\n  int32_T i;\n  int32_T nSamps;\n  int32_T offsetFromMemBase;\n  int32_T uIdx;\n  char_T *sErr;\n\n  /* S-Function (sdspwmmfi2): '<Root>/From Multimedia File' */\n  sErr = GetErrorBuffer(&bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n  LibOutputs_FromMMFile(&bucket_fft_DW.FromMultimediaFile_HostLib[0U],\n                        GetNullPointer(), &bucket_fft_B.FromMultimediaFile[0U],\n                        GetNullPointer(), GetNullPointer(), GetNullPointer());\n  if (*sErr != 0) {\n    rtmSetErrorStatus(bucket_fft_M, sErr);\n    rtmSetStopRequested(bucket_fft_M, 1);\n  }\n\n  /* End of S-Function (sdspwmmfi2): '<Root>/From Multimedia File' */\n\n  /* MATLAB Function: '<Root>/MATLAB Function3' incorporates:\n   *  S-Function (sdspwmmfi2): '<Root>/From Multimedia File'\n   */\n  memcpy(&bucket_fft_B.y[0], &bucket_fft_B.FromMultimediaFile[0], sizeof(real_T)\n         << 10U);\n\n  /* Chart: '<Root>/Chart' */\n  if (bucket_fft_DW.is_active_c4_bucket_fft == 0) {\n    bucket_fft_DW.is_active_c4_bucket_fft = 1U;\n    bucket_fft_B.speaker = 0.0;\n    bucket_fft_B.mode = 0.0;\n    bucket_fft_DW.is_c4_bucket_fft = bucket_fft_IN_IDLE;\n  } else {\n    switch (bucket_fft_DW.is_c4_bucket_fft) {\n     case bucket_fft_IN_IDLE:\n      bucket_fft_B.mode = 0.0;\n      bucket_fft_B.speaker = 1.0;\n      bucket_fft_DW.is_c4_bucket_fft = bucket_fft_IN_mp3Mode;\n      break;\n\n     case bucket_fft_IN_micMode:\n      bucket_fft_B.mode = 0.0;\n      bucket_fft_B.speaker = 1.0;\n      bucket_fft_DW.is_c4_bucket_fft = bucket_fft_IN_mp3Mode;\n      break;\n\n     default:\n      /* case IN_mp3Mode: */\n      break;\n    }\n  }\n\n  /* End of Chart: '<Root>/Chart' */\n  for (i = 0; i < 1024; i++) {\n    /* Switch: '<Root>/Switch1' */\n    if (bucket_fft_B.speaker > 0.0) {\n      /* Switch: '<Root>/Switch1' */\n      bucket_fft_B.Switch1[i] = bucket_fft_B.y[i];\n    } else {\n      /* Switch: '<Root>/Switch1' */\n      bucket_fft_B.Switch1[i] = 0.0;\n    }\n\n    /* End of Switch: '<Root>/Switch1' */\n  }\n\n  /* S-Function (saudioToAudioDevice): '<Root>/Audio Device Writer' incorporates:\n   *  Switch: '<Root>/Switch1'\n   */\n  sErr = GetErrorBuffer(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U]);\n  LibUpdate_Audio(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U],\n                  &bucket_fft_B.Switch1[0U], 0, 1024, 0U);\n  if (*sErr != 0) {\n    rtmSetErrorStatus(bucket_fft_M, sErr);\n    rtmSetStopRequested(bucket_fft_M, 1);\n  }\n\n  /* End of S-Function (saudioToAudioDevice): '<Root>/Audio Device Writer' */\n\n  /* S-Function (saudioFromAudioDevice): '<Root>/Audio Device Reader' */\n  sErr = GetErrorBuffer(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U]);\n  LibOutputs_Audio(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U],\n                   &bucket_fft_B.AudioDeviceReader[0U], 5, 1024, 0);\n  if (*sErr != 0) {\n    rtmSetErrorStatus(bucket_fft_M, sErr);\n    rtmSetStopRequested(bucket_fft_M, 1);\n  }\n\n  /* End of S-Function (saudioFromAudioDevice): '<Root>/Audio Device Reader' */\n\n  /* Switch: '<Root>/Switch' */\n  if (bucket_fft_B.mode > 0.0) {\n    /* Switch: '<Root>/Switch' incorporates:\n     *  S-Function (saudioFromAudioDevice): '<Root>/Audio Device Reader'\n     */\n    memcpy(&bucket_fft_B.y[0], &bucket_fft_B.AudioDeviceReader[0], sizeof(real_T)\n           << 10U);\n  }\n\n  /* End of Switch: '<Root>/Switch' */\n\n  /* Buffer: '<Root>/Buffer' incorporates:\n   *  Switch: '<Root>/Switch'\n   */\n  uIdx = 0;\n  nSamps = 40000;\n  offsetFromMemBase = bucket_fft_DW.Buffer_inBufPtrIdx;\n  if (bucket_fft_DW.Buffer_inBufPtrIdx > 38976) {\n    for (i = 0; i < 40000 - bucket_fft_DW.Buffer_inBufPtrIdx; i++) {\n      bucket_fft_DW.Buffer_CircBuf[bucket_fft_DW.Buffer_inBufPtrIdx + i] =\n        bucket_fft_B.y[i];\n    }\n\n    uIdx = 40000 - bucket_fft_DW.Buffer_inBufPtrIdx;\n    offsetFromMemBase = 0;\n    nSamps = bucket_fft_DW.Buffer_inBufPtrIdx;\n  }\n\n  for (i = 0; i < nSamps - 38976; i++) {\n    bucket_fft_DW.Buffer_CircBuf[offsetFromMemBase + i] = bucket_fft_B.y[uIdx +\n      i];\n  }\n\n  bucket_fft_DW.Buffer_inBufPtrIdx += 1024;\n  if (bucket_fft_DW.Buffer_inBufPtrIdx >= 40000) {\n    bucket_fft_DW.Buffer_inBufPtrIdx -= 40000;\n  }\n\n  /* End of Buffer: '<Root>/Buffer' */\n}\n\n/* Model step function for TID2 */\nvoid bucket_fft_step2(void)      /* Sample time: [0.44897959183673469s, 0.0s] */\n{\n  int32_T currentOffset;\n  int32_T i;\n  int32_T nSamps;\n  int32_T uyIdx;\n\n  /* Buffer: '<Root>/Buffer' */\n  uyIdx = 0;\n  currentOffset = bucket_fft_DW.Buffer_outBufPtrIdx - 200;\n  if (bucket_fft_DW.Buffer_outBufPtrIdx - 200 < 0) {\n    currentOffset = bucket_fft_DW.Buffer_outBufPtrIdx + 39800;\n  }\n\n  nSamps = 20000;\n  if (currentOffset > 20000) {\n    for (i = 0; i < 40000 - currentOffset; i++) {\n      bucket_fft_B.Buffer[i] = bucket_fft_DW.Buffer_CircBuf[currentOffset + i];\n    }\n\n    uyIdx = 40000 - currentOffset;\n    nSamps = currentOffset - 20000;\n    currentOffset = 0;\n  }\n\n  for (i = 0; i < nSamps; i++) {\n    bucket_fft_B.Buffer[uyIdx + i] = bucket_fft_DW.Buffer_CircBuf[currentOffset\n      + i];\n  }\n\n  currentOffset += nSamps;\n  if (currentOffset == 40000) {\n    currentOffset = 0;\n  }\n\n  bucket_fft_DW.Buffer_outBufPtrIdx = currentOffset;\n\n  /* End of Buffer: '<Root>/Buffer' */\n\n  /* S-Function (sdspfft2): '<Root>/FFT' incorporates:\n   *  Buffer: '<Root>/Buffer'\n   */\n  LibOutputs_FFT(&bucket_fft_DW.FFT_HostLib[0U], &bucket_fft_B.Buffer[0U],\n                 &bucket_fft_B.FFT[0U], 20000, 1);\n}\n\n/* Use this function only if you need to maintain compatibility with an existing static main program. */\nvoid bucket_fft_step(int_T tid)\n{\n  switch (tid) {\n   case 0 :\n    bucket_fft_step0();\n    break;\n\n   case 1 :\n    bucket_fft_step1();\n    break;\n\n   case 2 :\n    bucket_fft_step2();\n    break;\n\n   default :\n    /* do nothing */\n    break;\n  }\n}\n\n/* Model initialize function */\nvoid bucket_fft_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  {\n    char_T *sErr;\n\n    /* Start for S-Function (sdspwmmfi2): '<Root>/From Multimedia File' */\n    sErr = GetErrorBuffer(&bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n    CreateHostLibrary(\"libmwfrommmfile.dylib\",\n                      &bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n    createAudioInfo(&bucket_fft_DW.FromMultimediaFile_AudioInfo[0U], 1U, 0U,\n                    44100.0, 16, 2, 1024, 0, GetNullPointer());\n    createVideoInfo(&bucket_fft_DW.FromMultimediaFile_VideoInfo[0U], 0U, 0.0,\n                    0.0, \"\", 0, 0, 0, 0, 1U, 0, 0, GetNullPointer());\n    if (*sErr == 0) {\n      LibCreate_FromMMFile(&bucket_fft_DW.FromMultimediaFile_HostLib[0U], NULL,\n                           \"/Users/samstep/Documents/MATLAB/503/Final Project/20 - 20,000 Hz Audio Sweep ï½œ Range of Human Hearing - Sonic Electronix.mp3\",\n                           1,\n                           \"/Applications/MATLAB_R2024b.app/toolbox/shared/multimedia/bin/maca64/audio/libmwaudiofileatreaderplugin.dylib\",\n                           \"/Applications/MATLAB_R2024b.app/toolbox/shared/multimedia/bin/maca64/audioslconverter\",\n                           &bucket_fft_DW.FromMultimediaFile_AudioInfo[0U],\n                           &bucket_fft_DW.FromMultimediaFile_VideoInfo[0U], 0U,\n                           1U, 1U, 0U, 0U, 1U, 1.0, 9.2233720368547758E+18, 0U);\n    }\n\n    if (*sErr == 0) {\n      LibStart(&bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n    }\n\n    if (*sErr != 0) {\n      DestroyHostLibrary(&bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n      if (*sErr != 0) {\n        rtmSetErrorStatus(bucket_fft_M, sErr);\n        rtmSetStopRequested(bucket_fft_M, 1);\n      }\n    }\n\n    /* End of Start for S-Function (sdspwmmfi2): '<Root>/From Multimedia File' */\n\n    /* Start for S-Function (saudioToAudioDevice): '<Root>/Audio Device Writer' */\n    sErr = GetErrorBuffer(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U]);\n    CreateHostLibrary(\"libmwhostlibaudio.dylib\",\n                      &bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U]);\n    if (*sErr == 0) {\n      LibCreate_Audio(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U], 0,\n                      \"MacBook Pro Speakers\", 5, 1, 1, 44100.0, 3, 1024, 10240,\n                      1024, 0, NULL);\n    }\n\n    if (*sErr != 0) {\n      DestroyHostLibrary(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U]);\n      if (*sErr != 0) {\n        rtmSetErrorStatus(bucket_fft_M, sErr);\n        rtmSetStopRequested(bucket_fft_M, 1);\n      }\n    }\n\n    /* End of Start for S-Function (saudioToAudioDevice): '<Root>/Audio Device Writer' */\n\n    /* Start for S-Function (saudioFromAudioDevice): '<Root>/Audio Device Reader' */\n    sErr = GetErrorBuffer(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U]);\n    CreateHostLibrary(\"libmwhostlibaudio.dylib\",\n                      &bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U]);\n    if (*sErr == 0) {\n      LibCreate_Audio(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U], 0,\n                      \"Default\", 5, 0, 1, 44100.0, 3, 1024, 10240, 1024, 5, NULL);\n    }\n\n    if (*sErr != 0) {\n      DestroyHostLibrary(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U]);\n      if (*sErr != 0) {\n        rtmSetErrorStatus(bucket_fft_M, sErr);\n        rtmSetStopRequested(bucket_fft_M, 1);\n      }\n    }\n\n    /* End of Start for S-Function (saudioFromAudioDevice): '<Root>/Audio Device Reader' */\n\n    /* Start for S-Function (sdspfft2): '<Root>/FFT' incorporates:\n     *  Buffer: '<Root>/Buffer'\n     */\n    sErr = GetErrorBuffer(&bucket_fft_DW.FFT_HostLib[0U]);\n    CreateHostLibrary(\"libmwdspfft.dylib\", &bucket_fft_DW.FFT_HostLib[0U]);\n    if (*sErr == 0) {\n      LibCreate_FFT(&bucket_fft_DW.FFT_HostLib[0U], 20000, 1,\n                    &bucket_fft_B.Buffer_c[0U], &bucket_fft_B.FFT_m[0U], 0, 0, 0,\n                    2U, 1U, 0, 0, 0, 0, 1);\n    }\n\n    if (*sErr == 0) {\n      LibStart(&bucket_fft_DW.FFT_HostLib[0U]);\n    }\n\n    if (*sErr != 0) {\n      DestroyHostLibrary(&bucket_fft_DW.FFT_HostLib[0U]);\n      if (*sErr != 0) {\n        rtmSetErrorStatus(bucket_fft_M, sErr);\n        rtmSetStopRequested(bucket_fft_M, 1);\n      }\n    }\n\n    /* End of Start for S-Function (sdspfft2): '<Root>/FFT' */\n\n    /* InitializeConditions for S-Function (sdspwmmfi2): '<Root>/From Multimedia File' */\n    LibReset(&bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n\n    /* InitializeConditions for Buffer: '<Root>/Buffer' */\n    bucket_fft_DW.Buffer_inBufPtrIdx = 20000;\n    bucket_fft_DW.Buffer_outBufPtrIdx = 200;\n  }\n}\n\n/* Model terminate function */\nvoid bucket_fft_terminate(void)\n{\n  char_T *sErr;\n\n  /* Terminate for S-Function (sdspwmmfi2): '<Root>/From Multimedia File' */\n  sErr = GetErrorBuffer(&bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n  LibTerminate(&bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n  if (*sErr != 0) {\n    rtmSetErrorStatus(bucket_fft_M, sErr);\n    rtmSetStopRequested(bucket_fft_M, 1);\n  }\n\n  LibDestroy(&bucket_fft_DW.FromMultimediaFile_HostLib[0U], 0);\n  DestroyHostLibrary(&bucket_fft_DW.FromMultimediaFile_HostLib[0U]);\n\n  /* End of Terminate for S-Function (sdspwmmfi2): '<Root>/From Multimedia File' */\n\n  /* Terminate for S-Function (saudioToAudioDevice): '<Root>/Audio Device Writer' */\n  sErr = GetErrorBuffer(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U]);\n  LibTerminate(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U]);\n  if (*sErr != 0) {\n    rtmSetErrorStatus(bucket_fft_M, sErr);\n    rtmSetStopRequested(bucket_fft_M, 1);\n  }\n\n  LibDestroy_Audio(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U], 1, 1);\n  DestroyHostLibrary(&bucket_fft_DW.AudioDeviceWriter_AudioDeviceLi[0U]);\n\n  /* End of Terminate for S-Function (saudioToAudioDevice): '<Root>/Audio Device Writer' */\n\n  /* Terminate for S-Function (saudioFromAudioDevice): '<Root>/Audio Device Reader' */\n  sErr = GetErrorBuffer(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U]);\n  LibTerminate(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U]);\n  if (*sErr != 0) {\n    rtmSetErrorStatus(bucket_fft_M, sErr);\n    rtmSetStopRequested(bucket_fft_M, 1);\n  }\n\n  LibDestroy_Audio(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U], 0, 1);\n  DestroyHostLibrary(&bucket_fft_DW.AudioDeviceReader_AudioDeviceLi[0U]);\n\n  /* End of Terminate for S-Function (saudioFromAudioDevice): '<Root>/Audio Device Reader' */\n\n  /* Terminate for S-Function (sdspfft2): '<Root>/FFT' */\n  sErr = GetErrorBuffer(&bucket_fft_DW.FFT_HostLib[0U]);\n  LibTerminate(&bucket_fft_DW.FFT_HostLib[0U]);\n  if (*sErr != 0) {\n    rtmSetErrorStatus(bucket_fft_M, sErr);\n    rtmSetStopRequested(bucket_fft_M, 1);\n  }\n\n  LibDestroy(&bucket_fft_DW.FFT_HostLib[0U], 0);\n  DestroyHostLibrary(&bucket_fft_DW.FFT_HostLib[0U]);\n\n  /* End of Terminate for S-Function (sdspfft2): '<Root>/FFT' */\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"bucket_fft.h","type":"header","group":"model","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: bucket_fft.h\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bucket_fft_h_\n#define bucket_fft_h_\n#ifndef bucket_fft_COMMON_INCLUDES_\n#define bucket_fft_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#include \"HostLib_MMFile.h\"\n#include \"HostLib_Multimedia.h\"\n#include \"HostLib_Audio.h\"\n#include \"HostLib_FFT.h\"\n#endif                                 /* bucket_fft_COMMON_INCLUDES_ */\n\n#include \"bucket_fft_types.h\"\n#include \"rt_nonfinite.h\"\n#include <stddef.h>\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n#ifndef rtmStepTask\n#define rtmStepTask(rtm, idx)          ((rtm)->Timing.TaskCounters.TID[(idx)] == 0)\n#endif\n\n#ifndef rtmGetStopRequested\n#define rtmGetStopRequested(rtm)       ((rtm)->Timing.stopRequestedFlag)\n#endif\n\n#ifndef rtmSetStopRequested\n#define rtmSetStopRequested(rtm, val)  ((rtm)->Timing.stopRequestedFlag = (val))\n#endif\n\n#ifndef rtmGetStopRequestedPtr\n#define rtmGetStopRequestedPtr(rtm)    (&((rtm)->Timing.stopRequestedFlag))\n#endif\n\n#ifndef rtmTaskCounter\n#define rtmTaskCounter(rtm, idx)       ((rtm)->Timing.TaskCounters.TID[(idx)])\n#endif\n\n/* Block signals (default storage) */\ntypedef struct {\n  creal_T FFT[20000];                  /* '<Root>/FFT' */\n  creal_T FFT_m[20000];                /* '<Root>/FFT' */\n  real_T Buffer[20000];                /* '<Root>/Buffer' */\n  real_T Buffer_c[20000];              /* '<Root>/Buffer' */\n  real_T FromMultimediaFile[2048];     /* '<Root>/From Multimedia File' */\n  real_T Switch1[1024];                /* '<Root>/Switch1' */\n  real_T AudioDeviceReader[1024];      /* '<Root>/Audio Device Reader' */\n  real_T y[1024];                      /* '<Root>/MATLAB Function3' */\n  real_T mode;                         /* '<Root>/Chart' */\n  real_T speaker;                      /* '<Root>/Chart' */\n} B_bucket_fft_T;\n\n/* Block states (default storage) for system '<Root>' */\ntypedef struct {\n  real_T Buffer_CircBuf[40000];        /* '<Root>/Buffer' */\n  real_T FromMultimediaFile_HostLib[137];/* '<Root>/From Multimedia File' */\n  real_T FromMultimediaFile_AudioInfo[5];/* '<Root>/From Multimedia File' */\n  real_T FromMultimediaFile_VideoInfo[11];/* '<Root>/From Multimedia File' */\n  real_T FFT_HostLib[137];             /* '<Root>/FFT' */\n  int32_T Buffer_inBufPtrIdx;          /* '<Root>/Buffer' */\n  int32_T Buffer_outBufPtrIdx;         /* '<Root>/Buffer' */\n  uint8_T AudioDeviceWriter_AudioDeviceLi[1096];/* '<Root>/Audio Device Writer' */\n  uint8_T AudioDeviceReader_AudioDeviceLi[1096];/* '<Root>/Audio Device Reader' */\n  uint8_T is_active_c4_bucket_fft;     /* '<Root>/Chart' */\n  uint8_T is_c4_bucket_fft;            /* '<Root>/Chart' */\n} DW_bucket_fft_T;\n\n/* Real-time Model Data Structure */\nstruct tag_RTM_bucket_fft_T {\n  const char_T * volatile errorStatus;\n\n  /*\n   * Timing:\n   * The following substructure contains information regarding\n   * the timing information for the model.\n   */\n  struct {\n    struct {\n      uint16_T TID[3];\n    } TaskCounters;\n\n    boolean_T stopRequestedFlag;\n  } Timing;\n};\n\n/* Block signals (default storage) */\nextern B_bucket_fft_T bucket_fft_B;\n\n/* Block states (default storage) */\nextern DW_bucket_fft_T bucket_fft_DW;\n\n/* External function called from main */\nextern void bucket_fft_SetEventsForThisBaseStep(boolean_T *eventFlags);\n\n/* Model entry point functions */\nextern void bucket_fft_initialize(void);\nextern void bucket_fft_step0(void);\n                              /* Sample time: [0.00018140589569160998s, 0.0s] */\nextern void bucket_fft_step1(void);\n                                /* Sample time: [0.023219954648526078s, 0.0s] */\nextern void bucket_fft_step2(void);\n                                 /* Sample time: [0.44897959183673469s, 0.0s] */\nextern void bucket_fft_step(int_T tid);\nextern void bucket_fft_terminate(void);\n\n/* Real-time Model object */\nextern RT_MODEL_bucket_fft_T *const bucket_fft_M;\nextern volatile boolean_T stopRequested;\nextern volatile boolean_T runModel;\n\n/*-\n * These blocks were eliminated from the model due to optimizations:\n *\n * Block '<Root>/Scope' : Unused code path elimination\n */\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'bucket_fft'\n * '<S1>'   : 'bucket_fft/Chart'\n * '<S2>'   : 'bucket_fft/MATLAB Function'\n * '<S3>'   : 'bucket_fft/MATLAB Function1'\n * '<S4>'   : 'bucket_fft/MATLAB Function2'\n * '<S5>'   : 'bucket_fft/MATLAB Function3'\n */\n#endif                                 /* bucket_fft_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"bucket_fft_private.h","type":"header","group":"model","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: bucket_fft_private.h\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bucket_fft_private_h_\n#define bucket_fft_private_h_\n#include \"rtwtypes.h\"\n#include \"bucket_fft_types.h\"\n#endif                                 /* bucket_fft_private_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"bucket_fft_types.h","type":"header","group":"model","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: bucket_fft_types.h\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef bucket_fft_types_h_\n#define bucket_fft_types_h_\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM_bucket_fft_T RT_MODEL_bucket_fft_T;\n\n#endif                                 /* bucket_fft_types_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetInf.c\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T inf = 0.0;\n  if (bitsPerReal == 32U) {\n    inf = rtGetInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    inf = tmpVal.fltVal;\n  }\n\n  return inf;\n}\n\n/*\n * Initialize rtInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetInfF(void)\n{\n  IEEESingle infF;\n  infF.wordL.wordLuint = 0x7F800000U;\n  return infF.wordL.wordLreal;\n}\n\n/*\n * Initialize rtMinusInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetMinusInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T minf = 0.0;\n  if (bitsPerReal == 32U) {\n    minf = rtGetMinusInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    minf = tmpVal.fltVal;\n  }\n\n  return minf;\n}\n\n/*\n * Initialize rtMinusInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetMinusInfF(void)\n{\n  IEEESingle minfF;\n  minfF.wordL.wordLuint = 0xFF800000U;\n  return minfF.wordL.wordLreal;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetInf.h\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtGetInf_h_\n#define rtGetInf_h_\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n\nextern real_T rtGetInf(void);\nextern real32_T rtGetInfF(void);\nextern real_T rtGetMinusInf(void);\nextern real32_T rtGetMinusInfF(void);\n\n#endif                                 /* rtGetInf_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetNaN.c\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtwtypes.h\"\n#include \"rtGetNaN.h\"\n#include <stddef.h>\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\n/*\n * Initialize rtNaN needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal_T rtGetNaN(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T nan = 0.0;\n  if (bitsPerReal == 32U) {\n    nan = rtGetNaNF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    nan = tmpVal.fltVal;\n  }\n\n  return nan;\n}\n\n/*\n * Initialize rtNaNF needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nreal32_T rtGetNaNF(void)\n{\n  IEEESingle nanF = { { 0.0F } };\n\n  nanF.wordL.wordLuint = 0xFFC00000U;\n  return nanF.wordL.wordLreal;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtGetNaN.h\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtGetNaN_h_\n#define rtGetNaN_h_\n#include \"rt_nonfinite.h\"\n#include \"rtwtypes.h\"\n\nextern real_T rtGetNaN(void);\nextern real32_T rtGetNaNF(void);\n\n#endif                                 /* rtGetNaN_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_nonfinite.c\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#include \"rtGetNaN.h\"\n#include \"rtGetInf.h\"\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#include \"rt_nonfinite.h\"\n#define NumBitsPerChar                 8U\n\nreal_T rtInf;\nreal_T rtMinusInf;\nreal_T rtNaN;\nreal32_T rtInfF;\nreal32_T rtMinusInfF;\nreal32_T rtNaNF;\n\n/*\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n */\nvoid rt_InitInfAndNaN(size_t realSize)\n{\n  (void) (realSize);\n  rtNaN = rtGetNaN();\n  rtNaNF = rtGetNaNF();\n  rtInf = rtGetInf();\n  rtInfF = rtGetInfF();\n  rtMinusInf = rtGetMinusInf();\n  rtMinusInfF = rtGetMinusInfF();\n}\n\n/* Test if value is infinite */\nboolean_T rtIsInf(real_T value)\n{\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n}\n\n/* Test if single-precision value is infinite */\nboolean_T rtIsInfF(real32_T value)\n{\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n}\n\n/* Test if value is not a number */\nboolean_T rtIsNaN(real_T value)\n{\n  boolean_T result = (boolean_T) 0;\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  if (bitsPerReal == 32U) {\n    result = rtIsNaNF((real32_T)value);\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.fltVal = value;\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                          (tmpVal.bitVal.words.wordL != 0) ));\n  }\n\n  return result;\n}\n\n/* Test if single-precision value is not a number */\nboolean_T rtIsNaNF(real32_T value)\n{\n  IEEESingle tmp;\n  tmp.wordL.wordLreal = value;\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rt_nonfinite.h\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rt_nonfinite_h_\n#define rt_nonfinite_h_\n#include <stddef.h>\n#include \"rtwtypes.h\"\n#define NOT_USING_NONFINITE_LITERALS   1\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\nextern real32_T rtInfF;\nextern real32_T rtMinusInfF;\nextern real32_T rtNaNF;\nextern void rt_InitInfAndNaN(size_t realSize);\nextern boolean_T rtIsInf(real_T value);\nextern boolean_T rtIsInfF(real32_T value);\nextern boolean_T rtIsNaN(real_T value);\nextern boolean_T rtIsNaNF(real32_T value);\ntypedef struct {\n  struct {\n    uint32_T wordH;\n    uint32_T wordL;\n  } words;\n} BigEndianIEEEDouble;\n\ntypedef struct {\n  struct {\n    uint32_T wordL;\n    uint32_T wordH;\n  } words;\n} LittleEndianIEEEDouble;\n\ntypedef struct {\n  union {\n    real32_T wordLreal;\n    uint32_T wordLuint;\n  } wordL;\n} IEEESingle;\n\n#endif                                 /* rt_nonfinite_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: ARM Compatible->ARM Cortex-A (64-bit)\n *   Number of bits:     char:   8    short:   16    int:  32\n *                       long:  64    long long:  64\n *                       native word size:  64\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long int64_T;\ntypedef unsigned long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*===========================================================================*\n * Complex number type definitions                                           *\n *===========================================================================*/\n#define CREAL_T\n\ntypedef struct {\n  real32_T re;\n  real32_T im;\n} creal32_T;\n\ntypedef struct {\n  real64_T re;\n  real64_T im;\n} creal64_T;\n\ntypedef struct {\n  real_T re;\n  real_T im;\n} creal_T;\n\n#define CINT8_T\n\ntypedef struct {\n  int8_T re;\n  int8_T im;\n} cint8_T;\n\n#define CUINT8_T\n\ntypedef struct {\n  uint8_T re;\n  uint8_T im;\n} cuint8_T;\n\n#define CINT16_T\n\ntypedef struct {\n  int16_T re;\n  int16_T im;\n} cint16_T;\n\n#define CUINT16_T\n\ntypedef struct {\n  uint16_T re;\n  uint16_T im;\n} cuint16_T;\n\n#define CINT32_T\n\ntypedef struct {\n  int32_T re;\n  int32_T im;\n} cint32_T;\n\n#define CUINT32_T\n\ntypedef struct {\n  uint32_T re;\n  uint32_T im;\n} cuint32_T;\n\n#define CINT64_T\n\ntypedef struct {\n  int64_T re;\n  int64_T im;\n} cint64_T;\n\n#define CUINT64_T\n\ntypedef struct {\n  uint64_T re;\n  uint64_T im;\n} cuint64_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtmodel.h","type":"header","group":"interface","path":"/Users/samstep/Documents/MATLAB/503/Final Project/bucket_fft_ert_rtw","tag":"","groupDisplay":"Interface files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtmodel.h\n *\n * Code generated for Simulink model 'bucket_fft'.\n *\n * Model version                  : 3.21\n * Simulink Coder version         : 24.2 (R2024b) 21-Jun-2024\n * C/C++ source code generated on : Wed Jun 11 23:15:16 2025\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: ARM Compatible->ARM Cortex-A (64-bit)\n * Code generation objectives: Unspecified\n * Validation result: Not run\n */\n\n#ifndef rtmodel_h_\n#define rtmodel_h_\n#include \"bucket_fft.h\"\n#endif                                 /* rtmodel_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"DAHostLib_rtw.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024b.app/toolbox/shared/spc/src_ml/extern/src","tag":"","groupDisplay":"Static files","code":"/**\n * @file DAHostLib_rtw.c\n * @brief Helper for C clients of the HostLib library.\n * Copyright 2007-2017 The MathWorks, Inc.\n */ \n\n#include <string.h>\n#include <stdio.h>\n\n#include \"DAHostLib_rtw.h\"\n\n/* Open the library and initialize the function pointers */\nvoid CreateHostLibrary(const char *libName, void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    *hostLib->errorMessage = '\\0';\n    memset(hostLib, 0, sizeof(HostLibrary));\n#if defined(_WIN32)\n    hostLib->library = LoadLibrary(libName);\n    if(hostLib->library == NULL)\n        sprintf(hostLib->errorMessage, \"Could not open library: %s.\\nTo run the generated code outside the MATLAB environment, use the packNGo function.\\n\", libName);\n    else {\n        hostLib->libCreate    = GetProcAddress(hostLib->library, \"libCreate\");\n        hostLib->libStart     = GetProcAddress(hostLib->library, \"libStart\"); \n        hostLib->libReset     = GetProcAddress(hostLib->library, \"libReset\"); \n        hostLib->libUpdate    = GetProcAddress(hostLib->library, \"libUpdate\");\n        hostLib->libOutputs   = GetProcAddress(hostLib->library, \"libOutputs\");\n        hostLib->libTerminate = GetProcAddress(hostLib->library, \"libTerminate\");\n        hostLib->libDestroy   = GetProcAddress(hostLib->library, \"libDestroy\");\n    }\n#elif defined(_VXWORKS_)\n    hostLib->library = dlopen(libName, RTLD_NOW);\n    if(hostLib->library == NULL) {\n        sprintf(hostLib->errorMessage, \"Could not open library: %s\", libName);\n    }\n    else {\n        hostLib->libCreate    = dlsym(hostLib->library, \"libCreate\");\n        hostLib->libStart     = dlsym(hostLib->library, \"libStart\"); \n        hostLib->libReset     = dlsym(hostLib->library, \"libReset\"); \n        hostLib->libUpdate    = dlsym(hostLib->library, \"libUpdate\");\n        hostLib->libOutputs   = dlsym(hostLib->library, \"libOutputs\");\n        hostLib->libTerminate = dlsym(hostLib->library, \"libTerminate\");\n        hostLib->libDestroy   = dlsym(hostLib->library, \"libDestroy\");\n    }\n#else\n    hostLib->library = dlopen(libName, RTLD_NOW | RTLD_LOCAL);\n    if(hostLib->library == NULL) {\n        sprintf(hostLib->errorMessage, \"Could not open library: %s\", libName);\n    }\n    else {\n        hostLib->libCreate    = dlsym(hostLib->library, \"libCreate\");\n        hostLib->libStart     = dlsym(hostLib->library, \"libStart\"); \n        hostLib->libReset     = dlsym(hostLib->library, \"libReset\"); \n        hostLib->libUpdate    = dlsym(hostLib->library, \"libUpdate\");\n        hostLib->libOutputs   = dlsym(hostLib->library, \"libOutputs\");\n        hostLib->libTerminate = dlsym(hostLib->library, \"libTerminate\");\n        hostLib->libDestroy   = dlsym(hostLib->library, \"libDestroy\");\n    }\n#endif\n    if(!*hostLib->errorMessage && \n       (!hostLib->libCreate ||\n        !hostLib->libStart ||\n        !hostLib->libUpdate ||\n        !hostLib->libOutputs ||\n        !hostLib->libTerminate ||\n        !hostLib->libDestroy)\n        ) \n    {\n        sprintf(hostLib->errorMessage, \"Could not determine function entry points in %s\", libName);\n    }\n    if(*hostLib->errorMessage) {\n        if (hostLib->library) DestroyHostLibrary(hostLib);\n        fprintf(stderr,\"%s\",hostLib->errorMessage);\n    }\n}\n\n/* Close the library */\nvoid DestroyHostLibrary(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->library) {\n#if defined(_WIN32)\n        FreeLibrary(hostLib->library);\n#else\n        dlclose(hostLib->library);\n#endif\n        /* Clear the structure (except for any possible error message). */\n\t\tmemset(hostLib, 0, sizeof(HostLibrary) - MAX_ERR_MSG_LEN);\n    }\n}\n\nvoid LibStart(void *hl)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n        (MAKE_FCN_PTR(pFnLibStart,hostLib->libStart))(hostLib->instance, hostLib->errorMessage);\n}\n\nvoid LibReset(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance && hostLib->libReset)\n        (MAKE_FCN_PTR(pFnLibReset,hostLib->libReset))(hostLib->instance, hostLib->errorMessage);\n}\n\nvoid LibTerminate(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n        (MAKE_FCN_PTR(pFnLibTerminate,hostLib->libTerminate))(hostLib->instance, hostLib->errorMessage);\n}\n\nvoid LibDestroy(void *hl, int type)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n    {\n        (MAKE_FCN_PTR(pFnLibDestroy,hostLib->libDestroy))(hostLib->instance, hostLib->errorMessage, type);\n        hostLib->instance = NULL;\n    }\n}\n\nint LibError(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    return hostLib->errorMessage[0] != '\\0';\n}\nvoid PrintError(char *message)\n{\n    /* Print, and then reset, the error message */\n    printf(\"Error: %s\\n\", message);\n    message[0] = '\\0';\n}\nvoid PrintWarning(char *message)\n{\n    /* Print, and then reset, the warning message */\n    printf(\"Warning: %s\\n\", message);\n    message[0] = '\\0';\n}\nchar * GetErrorBuffer(void *hl) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    return hostLib->errorMessage;\n}\nvoid * GetNullPointer(void) \n{\n    return NULL;\n}\n"},{"name":"HostLib_Audio.c","type":"source","group":"legacy","path":"/Applications/MATLAB_R2024b.app/toolbox/dsp/dsp/include","tag":"","groupDisplay":"Static files","code":"/**\n * @file HostLib_Audio.c\n * @brief Helper for C clients of the HostLib library.\n * Copyright 2007-2017 The MathWorks, Inc.\n */ \n\n#include \"HostLib_Audio.h\"\n#include <string.h>\n#include <stdio.h>\n\n#if defined(_WIN32)\nconst char *libName_Audio = \"hostlibaudio.dll\";\n#elif defined(__APPLE__)\nconst char *libName_Audio = \"libmwhostlibaudio.dylib\";\n#else\nconst char *libName_Audio = \"libmwhostlibaudio.so\";\n#endif\n\nvoid LibCreate_Audio(void *hl, char *warn, const char *deviceName, int apiID, int inOut,\n                     int numChannels, double sampleRate, int deviceDatatype, int bufferSize, int queueDuration,\n                     int frameSize, int signalDatatype, int* channelMap) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    *hostLib->errorMessage  = '\\0';\n    if(warn)\n    {\n        *warn = '\\0';\n    }\n    (MAKE_FCN_PTR(pFnLibCreate_Audio,hostLib->libCreate))(hostLib->errorMessage, warn, deviceName, apiID, inOut, &hostLib->instance,\n                                                    numChannels, sampleRate, deviceDatatype, bufferSize, queueDuration,\n                                                    frameSize, signalDatatype, channelMap);\n}\nvoid LibUpdate_Audio(void *hl, const void *src, int signalDatatype, int samplesPerFrame, unsigned int *nDroppedSamples) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n        (MAKE_FCN_PTR(pFnLibUpdate_Audio,hostLib->libUpdate))(hostLib->instance, hostLib->errorMessage, src, signalDatatype, samplesPerFrame, (int *)nDroppedSamples);\n}\nvoid LibOutputs_Audio(void *hl, void *src, int signalDatatype, int samplesPerFrame, unsigned int *nDroppedSamples) \n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if(hostLib->instance)\n        (MAKE_FCN_PTR(pFnLibOutputs_Audio,hostLib->libOutputs))(hostLib->instance, hostLib->errorMessage, src, signalDatatype, samplesPerFrame, (int *)nDroppedSamples);\n}\nvoid LibDestroy_Audio(void *hl, int type, int mode)\n{\n    HostLibrary *hostLib = (HostLibrary*)hl;\n    if (hostLib->instance)\n    {\n        (MAKE_FCN_PTR(pFnLibDestroy_Audio, hostLib->libDestroy))(hostLib->instance, hostLib->errorMessage, type, mode);\n        hostLib->instance = NULL;\n    }\n}"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":true,"showJustificationLinks":true,"useMWTable":false,"showProfilingInfo":true,"showTaskSummary":true,"showProtectedV2Report":true}};