#include "bucket_fft.h"
#include "rtwtypes.h"
#include <stddef.h>
#include "mwmathutil.h"
#include <string.h>
#include "rt_logging_mmi.h"
#include "bucket_fft_capi.h"
#include "bucket_fft_dt.h"
extern void * CreateDiagnosticAsVoidPtr_wrapper ( const char * id , int nargs
, ... ) ; extern ssExecutionInfo gblExecutionInfo ; RTWExtModeInfo *
gblRTWExtModeInfo = NULL ; void raccelForceExtModeShutdown ( boolean_T
extModeStartPktReceived ) { if ( ! extModeStartPktReceived ) { boolean_T
stopRequested = false ; rtExtModeWaitForStartPkt ( gblRTWExtModeInfo , 3 , &
stopRequested ) ; } rtExtModeShutdown ( 3 ) ; }
#include "slsv_diagnostic_codegen_c_api.h"
#include "slsa_engine_exec.h"
#ifdef RSIM_WITH_SOLVER_MULTITASKING
boolean_T gbl_raccel_isMultitasking = 1 ;
#else
boolean_T gbl_raccel_isMultitasking = 0 ;
#endif
boolean_T gbl_raccel_tid01eq = 0 ; int_T gbl_raccel_NumST = 4 ; const char_T
* gbl_raccel_Version = "24.2 (R2024b) 21-Jun-2024" ; void
raccel_setup_MMIStateLog ( SimStruct * S ) {
#ifdef UseMMIDataLogging
rt_FillStateSigInfoFromMMI ( ssGetRTWLogInfo ( S ) , & ssGetErrorStatus ( S )
) ;
#else
UNUSED_PARAMETER ( S ) ;
#endif
} static DataMapInfo rt_dataMapInfo ; DataMapInfo * rt_dataMapInfoPtr = &
rt_dataMapInfo ; rtwCAPI_ModelMappingInfo * rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; int_T enableFcnCallFlag [ ] = { 1 , 1 , 1 , 1 } ; const char * raccelLoadInputsAndAperiodicHitTimes ( SimStruct * S , const char * inportFileName , int * matFileFormat ) { return rt_RAccelReadInportsMatFile ( S , inportFileName , matFileFormat ) ; }
#include "simstruc.h"
#include "fixedpoint.h"
#include "slsa_engine_exec.h"
#include "simtarget/slSimTgtSLExecSimBridge.h"
#define b3vxrie55s (-1)
#define cfgxibt24b (1U)
#define emqqk0y5m5 (3U)
#define fhq0y1kz3l ((uint8_T)0U)
#define iicxkvcmxd (2U)
#define bndqr1gebg (20000.0)
B rtB ; DW rtDW ; static SimStruct model_S ; SimStruct * const rtS = &
model_S ; void MdlInitialize ( void ) { int32_T i ; LibReset ( & rtDW .
nr2inbcx3w [ 0U ] ) ; for ( i = 0 ; i < 40000 ; i ++ ) { rtDW . eevlbptizq [
i ] = rtP . Buffer_ic ; } rtDW . ksb220rab2 = 20000 ; rtDW . dhaotaxhrp =
20000 ; rtDW . aiwfpkwj3j = 200 ; rtDW . giubrblnl2 = false ; rtDW .
cpqu5t1geo = b3vxrie55s ; rtDW . ls4dwl451y = b3vxrie55s ; rtB . bwikhqgzi1 =
0.0 ; rtB . mzsfr4barx = 0.0 ; rtDW . d431oespjx = 0U ; rtDW . m2b2bdbdfb =
fhq0y1kz3l ; rtDW . j1ojzjtxum = false ; rtDW . kvtskrthpe = b3vxrie55s ;
rtDW . gfdptv1xsh = false ; rtDW . izi2tami0i = b3vxrie55s ; rtDW .
p4hudmdwnu = false ; rtDW . oykxmdtwre = b3vxrie55s ; } void MdlStart ( void
) { char_T * sErr ; { bool externalInputIsInDatasetFormat = false ; void *
pISigstreamManager = rt_GetISigstreamManager ( rtS ) ;
rtwISigstreamManagerGetInputIsInDatasetFormat ( pISigstreamManager , &
externalInputIsInDatasetFormat ) ; if ( externalInputIsInDatasetFormat ) { }
} rtB . iu1mablgic = rtP . Constant4_Value ; sErr = GetErrorBuffer ( & rtDW .
nr2inbcx3w [ 0U ] ) ; CreateHostLibrary ( "libmwfrommmfile.dylib" , & rtDW .
nr2inbcx3w [ 0U ] ) ; createAudioInfo ( & rtDW . oqn3pi044w [ 0U ] , 1U , 0U
, 44100.0 , 16 , 2 , 1024 , 0 , GetNullPointer ( ) ) ; createVideoInfo ( &
rtDW . e2vq1vlryh [ 0U ] , 0U , 0.0 , 0.0 , "" , 0 , 0 , 0 , 0 , 1U , 0 , 0 ,
GetNullPointer ( ) ) ; if ( * sErr == 0 ) { LibCreate_FromMMFile ( & rtDW .
nr2inbcx3w [ 0U ] , NULL ,
 "/Users/samstep/Documents/MATLAB/503/Final Project/20 - 20,000 Hz Audio Sweep ï½œ Range of Human Hearing - Sonic Electronix.mp3"
, 1 ,
 "/Applications/MATLAB_R2024b.app/toolbox/shared/multimedia/bin/maca64/audio/libmwaudiofileatreaderplugin.dylib"
,
 "/Applications/MATLAB_R2024b.app/toolbox/shared/multimedia/bin/maca64/audioslconverter"
, & rtDW . oqn3pi044w [ 0U ] , & rtDW . e2vq1vlryh [ 0U ] , 0U , 1U , 1U , 0U
, 0U , 1U , 1.0 , 9.2233720368547758E+18 , 0U ) ; } if ( * sErr == 0 ) {
LibStart ( & rtDW . nr2inbcx3w [ 0U ] ) ; } if ( * sErr != 0 ) {
DestroyHostLibrary ( & rtDW . nr2inbcx3w [ 0U ] ) ; if ( * sErr != 0 ) {
ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } } sErr =
GetErrorBuffer ( & rtDW . gzgwm4aj3x [ 0U ] ) ; CreateHostLibrary ( "libmwhostlibaudio.dylib" , & rtDW . gzgwm4aj3x [ 0U ] ) ; if ( * sErr == 0 ) { LibCreate_Audio ( & rtDW . gzgwm4aj3x [ 0U ] , 0 , "MacBook Pro Speakers" , 5 , 1 , 1 , 44100.0 , 3 , 1024 , 10240 , 1024 , 0 , NULL ) ; } if ( * sErr != 0 ) { DestroyHostLibrary ( & rtDW . gzgwm4aj3x [ 0U ] ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } } sErr = GetErrorBuffer ( & rtDW . l05wjbovmj [ 0U ] ) ; CreateHostLibrary ( "libmwhostlibaudio.dylib" , & rtDW . l05wjbovmj [ 0U ] ) ; if ( * sErr == 0 ) { LibCreate_Audio ( & rtDW . l05wjbovmj [ 0U ] , 0 , "Default" , 5 , 0 , 1 , 44100.0 , 3 , 1024 , 10240 , 1024 , 5 , NULL ) ; } if ( * sErr != 0 ) { DestroyHostLibrary ( & rtDW . l05wjbovmj [ 0U ] ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } } sErr = GetErrorBuffer ( & rtDW . onrqffi2a1 [ 0U ] ) ; CreateHostLibrary ( "libmwdspfft.dylib" , & rtDW . onrqffi2a1 [ 0U ] ) ; if ( * sErr == 0 ) { LibCreate_FFT ( & rtDW . onrqffi2a1 [ 0U ] , 20000 , 1 , & rtB . n5uqvvdbb0_kkiq3xxxve [ 0U ] , & rtB . gpc5jt3hp0_mbvzarwird [ 0U ] , 0 , 0 , 0 , 2U , 1U , 0 , 0 , 0 , 0 , 1 ) ; } if ( * sErr == 0 ) { LibStart ( & rtDW . onrqffi2a1 [ 0U ] ) ; } if ( * sErr != 0 ) { DestroyHostLibrary ( & rtDW . onrqffi2a1 [ 0U ] ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } } MdlInitialize ( ) ; } void MdlOutputs ( int_T tid ) { real_T freq_edges [ 31 ] ; real_T d2scaled ; real_T delta1 ; real_T delta2 ; int32_T i ; int32_T memIdx ; int32_T nSamps ; int32_T uIdx ; char_T * sErr ; if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { sErr = GetErrorBuffer ( & rtDW . nr2inbcx3w [ 0U ] ) ; LibOutputs_FromMMFile ( & rtDW . nr2inbcx3w [ 0U ] , GetNullPointer ( ) , & rtB . fm2bclfi1a [ 0U ] , GetNullPointer ( ) , GetNullPointer ( ) , GetNullPointer ( ) ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } rtDW . cpqu5t1geo = b3vxrie55s ; memcpy ( & rtB . jfsc5bkbri [ 0 ] , & rtB . fm2bclfi1a [ 0 ] , sizeof ( real_T ) << 10U ) ; rtDW . ls4dwl451y = b3vxrie55s ; if ( rtDW . d431oespjx == 0 ) { rtDW . d431oespjx = 1U ; rtB . mzsfr4barx = 0.0 ; rtB . bwikhqgzi1 = 0.0 ; rtDW . m2b2bdbdfb = cfgxibt24b ; } else { switch ( rtDW . m2b2bdbdfb ) { case cfgxibt24b : if ( rtB . iu1mablgic == 1.0 ) { rtB . bwikhqgzi1 = 1.0 ; rtB . mzsfr4barx = 0.0 ; rtDW . m2b2bdbdfb = iicxkvcmxd ; } else if ( rtB . iu1mablgic == 2.0 ) { rtB . bwikhqgzi1 = 0.0 ; rtB . mzsfr4barx = 1.0 ; rtDW . m2b2bdbdfb = emqqk0y5m5 ; } break ; case iicxkvcmxd : if ( rtB . iu1mablgic == 2.0 ) { rtB . bwikhqgzi1 = 0.0 ; rtB . mzsfr4barx = 1.0 ; rtDW . m2b2bdbdfb = emqqk0y5m5 ; } break ; default : if ( rtB . iu1mablgic == 0.0 ) { rtB . mzsfr4barx = 0.0 ; rtB . bwikhqgzi1 = 0.0 ; rtDW . m2b2bdbdfb = cfgxibt24b ; } else if ( rtB . iu1mablgic == 1.0 ) { rtB . bwikhqgzi1 = 1.0 ; rtB . mzsfr4barx = 0.0 ; rtDW . m2b2bdbdfb = iicxkvcmxd ; } break ; } } for ( i = 0 ; i < 1024 ; i ++ ) { if ( rtB . mzsfr4barx > rtP . Switch1_Threshold ) { rtB . bpytsqbdv1 [ i ] = rtB . jfsc5bkbri [ i ] ; } else { rtB . bpytsqbdv1 [ i ] = 0.0 ; } } sErr = GetErrorBuffer ( & rtDW . gzgwm4aj3x [ 0U ] ) ; LibUpdate_Audio ( & rtDW . gzgwm4aj3x [ 0U ] , & rtB . bpytsqbdv1 [ 0U ] , 0 , 1024 , 0U ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtDW . kvtskrthpe = b3vxrie55s ; d2scaled = muDoubleScalarLog10 ( muDoubleScalarCeil ( rtP . Constant1_Value * bndqr1gebg / rtP . Constant3_Value ) ) ; delta2 = muDoubleScalarLog10 ( muDoubleScalarFloor ( rtP . Constant2_Value * bndqr1gebg / rtP . Constant3_Value ) ) ; freq_edges [ 30 ] = delta2 ; freq_edges [ 0 ] = d2scaled ; if ( d2scaled == - delta2 ) { d2scaled = delta2 / 30.0 ; for ( i = 0 ; i < 29 ; i ++ ) { freq_edges [ i + 1 ] = ( ( ( real_T ) i + 2.0 ) * 2.0 - 32.0 ) * d2scaled ; } freq_edges [ 15 ] = 0.0 ; } else if ( ( ( d2scaled < 0.0 ) != ( delta2 < 0.0 ) ) && ( ( muDoubleScalarAbs ( d2scaled ) > 8.9884656743115785E+307 ) || ( muDoubleScalarAbs ( delta2 ) > 8.9884656743115785E+307 ) ) ) { delta1 = d2scaled / 30.0 ; delta2 /= 30.0 ; for ( i = 0 ; i < 29 ; i ++ ) { freq_edges [ i + 1 ] = ( ( ( real_T ) i + 1.0 ) * delta2 + d2scaled ) - ( ( real_T ) i + 1.0 ) * delta1 ; } } else { delta1 = ( delta2 - d2scaled ) / 30.0 ; for ( i = 0 ; i < 29 ; i ++ ) { freq_edges [ i + 1 ] = ( ( real_T ) i + 1.0 ) * delta1 + d2scaled ; } } for ( i = 0 ; i < 31 ; i ++ ) { rtB . cnwnvnufnf [ i ] = muDoubleScalarPower ( 10.0 , freq_edges [ i ] ) ; rtB . cnwnvnufnf [ i ] = muDoubleScalarCeil ( rtB . cnwnvnufnf [ i ] ) ; } } if ( ssIsSampleHit ( rtS , 1 , 0 ) ) { sErr = GetErrorBuffer ( & rtDW . l05wjbovmj [ 0U ] ) ; LibOutputs_Audio ( & rtDW . l05wjbovmj [ 0U ] , & rtB . ckdk3dpzbc [ 0U ] , 5 , 1024 , 0 ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } if ( rtB . bwikhqgzi1 > rtP . Switch_Threshold ) { memcpy ( & rtB . a2r1rksip5 [ 0 ] , & rtB . ckdk3dpzbc [ 0 ] , sizeof ( real_T ) << 10U ) ; } else { memcpy ( & rtB . a2r1rksip5 [ 0 ] , & rtB . jfsc5bkbri [ 0 ] , sizeof ( real_T ) << 10U ) ; } uIdx = 0 ; nSamps = 40000 ; memIdx = rtDW . ksb220rab2 ; if ( rtDW . ksb220rab2 > 38976 ) { for ( i = 0 ; i < 40000 - rtDW . ksb220rab2 ; i ++ ) { rtDW . eevlbptizq [ rtDW . ksb220rab2 + i ] = rtB . a2r1rksip5 [ i ] ; } uIdx = 40000 - rtDW . ksb220rab2 ; memIdx = 0 ; nSamps = rtDW . ksb220rab2 ; } for ( i = 0 ; i < nSamps - 38976 ; i ++ ) { rtDW . eevlbptizq [ memIdx + i ] = rtB . a2r1rksip5 [ uIdx + i ] ; } rtDW . ksb220rab2 += 1024 ; if ( rtDW . ksb220rab2 >= 40000 ) { rtDW . ksb220rab2 -= 40000 ; } rtDW . dhaotaxhrp += 1024 ; if ( rtDW . dhaotaxhrp > 40000 ) { rtDW . aiwfpkwj3j = ( rtDW . aiwfpkwj3j + rtDW . dhaotaxhrp ) - 40000 ; if ( rtDW . aiwfpkwj3j > 40000 ) { rtDW . aiwfpkwj3j -= 40000 ; } rtDW . dhaotaxhrp = 40000 ; } } if ( ssIsSampleHit ( rtS , 2 , 0 ) ) { rtDW . dhaotaxhrp -= 19800 ; if ( rtDW . dhaotaxhrp < 200 ) { rtDW . aiwfpkwj3j = ( rtDW . aiwfpkwj3j + rtDW . dhaotaxhrp ) - 200 ; if ( rtDW . aiwfpkwj3j < 0 ) { rtDW . aiwfpkwj3j += 40000 ; } rtDW . dhaotaxhrp = 200 ; } uIdx = 0 ; memIdx = rtDW . aiwfpkwj3j - 200 ; if ( rtDW . aiwfpkwj3j - 200 < 0 ) { memIdx = rtDW . aiwfpkwj3j + 39800 ; } nSamps = 20000 ; if ( memIdx > 20000 ) { for ( i = 0 ; i < 40000 - memIdx ; i ++ ) { rtB . n5uqvvdbb0_cxarnvbvui [ i ] = rtDW . eevlbptizq [ memIdx + i ] ; } uIdx = 40000 - memIdx ; nSamps = memIdx - 20000 ; memIdx = 0 ; } for ( i = 0 ; i < nSamps ; i ++ ) { rtB . n5uqvvdbb0_cxarnvbvui [ uIdx + i ] = rtDW . eevlbptizq [ memIdx + i ] ; } memIdx += nSamps ; if ( memIdx == 40000 ) { memIdx = 0 ; } rtDW . aiwfpkwj3j = memIdx ; LibOutputs_FFT ( & rtDW . onrqffi2a1 [ 0U ] , & rtB . n5uqvvdbb0_cxarnvbvui [ 0U ] , & rtB . gpc5jt3hp0_cl54gopm0x [ 0U ] , 20000 , 1 ) ; rtDW . izi2tami0i = b3vxrie55s ; rtDW . oykxmdtwre = b3vxrie55s ; } UNUSED_PARAMETER ( tid ) ; } void MdlOutputsTID3 ( int_T tid ) { rtB . iu1mablgic = rtP . Constant4_Value ; UNUSED_PARAMETER ( tid ) ; } void MdlUpdate ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlUpdateTID3 ( int_T tid ) { UNUSED_PARAMETER ( tid ) ; } void MdlTerminate ( void ) { char_T * sErr ; sErr = GetErrorBuffer ( & rtDW . nr2inbcx3w [ 0U ] ) ; LibTerminate ( & rtDW . nr2inbcx3w [ 0U ] ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } LibDestroy ( & rtDW . nr2inbcx3w [ 0U ] , 0 ) ; DestroyHostLibrary ( & rtDW . nr2inbcx3w [ 0U ] ) ; sErr = GetErrorBuffer ( & rtDW . gzgwm4aj3x [ 0U ] ) ; LibTerminate ( & rtDW . gzgwm4aj3x [ 0U ] ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } LibDestroy_Audio ( & rtDW . gzgwm4aj3x [ 0U ] , 1 , 1 ) ; DestroyHostLibrary ( & rtDW . gzgwm4aj3x [ 0U ] ) ; sErr = GetErrorBuffer ( & rtDW . l05wjbovmj [ 0U ] ) ; LibTerminate ( & rtDW . l05wjbovmj [ 0U ] ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } LibDestroy_Audio ( & rtDW . l05wjbovmj [ 0U ] , 0 , 1 ) ; DestroyHostLibrary ( & rtDW . l05wjbovmj [ 0U ] ) ; sErr = GetErrorBuffer ( & rtDW . onrqffi2a1 [ 0U ] ) ; LibTerminate ( & rtDW . onrqffi2a1 [ 0U ] ) ; if ( * sErr != 0 ) { ssSetErrorStatus ( rtS , sErr ) ; ssSetStopRequested ( rtS , 1 ) ; } LibDestroy ( & rtDW . onrqffi2a1 [ 0U ] , 0 ) ; DestroyHostLibrary ( & rtDW . onrqffi2a1 [ 0U ] ) ; } static void mr_bucket_fft_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) ; static void mr_bucket_fft_cacheDataAsMxArray ( mxArray * destArray , mwIndex i , int j , const void * srcData , size_t numBytes ) { mxArray * newArray = mxCreateUninitNumericMatrix ( ( size_t ) 1 , numBytes , mxUINT8_CLASS , mxREAL ) ; memcpy ( ( uint8_T * ) mxGetData ( newArray ) , ( const uint8_T * ) srcData , numBytes ) ; mxSetFieldByNumber ( destArray , i , j , newArray ) ; } static void mr_bucket_fft_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) ; static void mr_bucket_fft_restoreDataFromMxArray ( void * destData , const mxArray * srcArray , mwIndex i , int j , size_t numBytes ) { memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) , numBytes ) ; } static void mr_bucket_fft_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) ; static void mr_bucket_fft_cacheBitFieldToMxArray ( mxArray * destArray , mwIndex i , int j , uint_T bitVal ) { mxSetFieldByNumber ( destArray , i , j , mxCreateDoubleScalar ( ( real_T ) bitVal ) ) ; } static uint_T mr_bucket_fft_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) ; static uint_T mr_bucket_fft_extractBitFieldFromMxArray ( const mxArray * srcArray , mwIndex i , int j , uint_T numBits ) { const uint_T varVal = ( uint_T ) mxGetScalar ( mxGetFieldByNumber ( srcArray , i , j ) ) ; return varVal & ( ( 1u << numBits ) - 1u ) ; } static void mr_bucket_fft_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) ; static void mr_bucket_fft_cacheDataToMxArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , const void * srcData , size_t numBytes ) { uint8_T * varData = ( uint8_T * ) mxGetData ( mxGetFieldByNumber ( destArray , i , j ) ) ; memcpy ( ( uint8_T * ) & varData [ offset * numBytes ] , ( const uint8_T * ) srcData , numBytes ) ; } static void mr_bucket_fft_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) ; static void mr_bucket_fft_restoreDataFromMxArrayWithOffset ( void * destData , const mxArray * srcArray , mwIndex i , int j , mwIndex offset , size_t numBytes ) { const uint8_T * varData = ( const uint8_T * ) mxGetData ( mxGetFieldByNumber ( srcArray , i , j ) ) ; memcpy ( ( uint8_T * ) destData , ( const uint8_T * ) & varData [ offset * numBytes ] , numBytes ) ; } static void mr_bucket_fft_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) ; static void mr_bucket_fft_cacheBitFieldToCellArrayWithOffset ( mxArray * destArray , mwIndex i , int j , mwIndex offset , uint_T fieldVal ) { mxSetCell ( mxGetFieldByNumber ( destArray , i , j ) , offset , mxCreateDoubleScalar ( ( real_T ) fieldVal ) ) ; } static uint_T mr_bucket_fft_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) ; static uint_T mr_bucket_fft_extractBitFieldFromCellArrayWithOffset ( const mxArray * srcArray , mwIndex i , int j , mwIndex offset , uint_T numBits ) { const uint_T fieldVal = ( uint_T ) mxGetScalar ( mxGetCell ( mxGetFieldByNumber ( srcArray , i , j ) , offset ) ) ; return fieldVal & ( ( 1u << numBits ) - 1u ) ; } mxArray * mr_bucket_fft_GetDWork ( ) { static const char_T * ssDWFieldNames [ 3 ] = { "rtB" , "rtDW" , "NULL_PrevZCX" , } ; mxArray * ssDW = mxCreateStructMatrix ( 1 , 1 , 3 , ssDWFieldNames ) ; mr_bucket_fft_cacheDataAsMxArray ( ssDW , 0 , 0 , ( const void * ) & ( rtB ) , sizeof ( rtB ) ) ; { static const char_T * rtdwDataFieldNames [ 18 ] = { "rtDW.eevlbptizq" , "rtDW.nr2inbcx3w" , "rtDW.oqn3pi044w" , "rtDW.e2vq1vlryh" , "rtDW.ksb220rab2" , "rtDW.aiwfpkwj3j" , "rtDW.dhaotaxhrp" , "rtDW.cpqu5t1geo" , "rtDW.kvtskrthpe" , "rtDW.oykxmdtwre" , "rtDW.izi2tami0i" , "rtDW.ls4dwl451y" , "rtDW.m2b2bdbdfb" , "rtDW.d431oespjx" , "rtDW.giubrblnl2" , "rtDW.j1ojzjtxum" , "rtDW.p4hudmdwnu" , "rtDW.gfdptv1xsh" , } ; mxArray * rtdwData = mxCreateStructMatrix ( 1 , 1 , 18 , rtdwDataFieldNames ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 0 , ( const void * ) & ( rtDW . eevlbptizq ) , sizeof ( rtDW . eevlbptizq ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 1 , ( const void * ) & ( rtDW . nr2inbcx3w ) , sizeof ( rtDW . nr2inbcx3w ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 2 , ( const void * ) & ( rtDW . oqn3pi044w ) , sizeof ( rtDW . oqn3pi044w ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 3 , ( const void * ) & ( rtDW . e2vq1vlryh ) , sizeof ( rtDW . e2vq1vlryh ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 4 , ( const void * ) & ( rtDW . ksb220rab2 ) , sizeof ( rtDW . ksb220rab2 ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 5 , ( const void * ) & ( rtDW . aiwfpkwj3j ) , sizeof ( rtDW . aiwfpkwj3j ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 6 , ( const void * ) & ( rtDW . dhaotaxhrp ) , sizeof ( rtDW . dhaotaxhrp ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 7 , ( const void * ) & ( rtDW . cpqu5t1geo ) , sizeof ( rtDW . cpqu5t1geo ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 8 , ( const void * ) & ( rtDW . kvtskrthpe ) , sizeof ( rtDW . kvtskrthpe ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 9 , ( const void * ) & ( rtDW . oykxmdtwre ) , sizeof ( rtDW . oykxmdtwre ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 10 , ( const void * ) & ( rtDW . izi2tami0i ) , sizeof ( rtDW . izi2tami0i ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 11 , ( const void * ) & ( rtDW . ls4dwl451y ) , sizeof ( rtDW . ls4dwl451y ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 12 , ( const void * ) & ( rtDW . m2b2bdbdfb ) , sizeof ( rtDW . m2b2bdbdfb ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 13 , ( const void * ) & ( rtDW . d431oespjx ) , sizeof ( rtDW . d431oespjx ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 14 , ( const void * ) & ( rtDW . giubrblnl2 ) , sizeof ( rtDW . giubrblnl2 ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 15 , ( const void * ) & ( rtDW . j1ojzjtxum ) , sizeof ( rtDW . j1ojzjtxum ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 16 , ( const void * ) & ( rtDW . p4hudmdwnu ) , sizeof ( rtDW . p4hudmdwnu ) ) ; mr_bucket_fft_cacheDataAsMxArray ( rtdwData , 0 , 17 , ( const void * ) & ( rtDW . gfdptv1xsh ) , sizeof ( rtDW . gfdptv1xsh ) ) ; mxSetFieldByNumber ( ssDW , 0 , 1 , rtdwData ) ; } return ssDW ; } void mr_bucket_fft_SetDWork ( const mxArray * ssDW ) { ( void ) ssDW ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtB ) , ssDW , 0 , 0 , sizeof ( rtB ) ) ; { const mxArray * rtdwData = mxGetFieldByNumber ( ssDW , 0 , 1 ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . eevlbptizq ) , rtdwData , 0 , 0 , sizeof ( rtDW . eevlbptizq ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . nr2inbcx3w ) , rtdwData , 0 , 1 , sizeof ( rtDW . nr2inbcx3w ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . oqn3pi044w ) , rtdwData , 0 , 2 , sizeof ( rtDW . oqn3pi044w ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . e2vq1vlryh ) , rtdwData , 0 , 3 , sizeof ( rtDW . e2vq1vlryh ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . ksb220rab2 ) , rtdwData , 0 , 4 , sizeof ( rtDW . ksb220rab2 ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . aiwfpkwj3j ) , rtdwData , 0 , 5 , sizeof ( rtDW . aiwfpkwj3j ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . dhaotaxhrp ) , rtdwData , 0 , 6 , sizeof ( rtDW . dhaotaxhrp ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . cpqu5t1geo ) , rtdwData , 0 , 7 , sizeof ( rtDW . cpqu5t1geo ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . kvtskrthpe ) , rtdwData , 0 , 8 , sizeof ( rtDW . kvtskrthpe ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . oykxmdtwre ) , rtdwData , 0 , 9 , sizeof ( rtDW . oykxmdtwre ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . izi2tami0i ) , rtdwData , 0 , 10 , sizeof ( rtDW . izi2tami0i ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . ls4dwl451y ) , rtdwData , 0 , 11 , sizeof ( rtDW . ls4dwl451y ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . m2b2bdbdfb ) , rtdwData , 0 , 12 , sizeof ( rtDW . m2b2bdbdfb ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . d431oespjx ) , rtdwData , 0 , 13 , sizeof ( rtDW . d431oespjx ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . giubrblnl2 ) , rtdwData , 0 , 14 , sizeof ( rtDW . giubrblnl2 ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . j1ojzjtxum ) , rtdwData , 0 , 15 , sizeof ( rtDW . j1ojzjtxum ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . p4hudmdwnu ) , rtdwData , 0 , 16 , sizeof ( rtDW . p4hudmdwnu ) ) ; mr_bucket_fft_restoreDataFromMxArray ( ( void * ) & ( rtDW . gfdptv1xsh ) , rtdwData , 0 , 17 , sizeof ( rtDW . gfdptv1xsh ) ) ; } } mxArray * mr_bucket_fft_GetSimStateDisallowedBlocks ( ) { mxArray * data = mxCreateCellMatrix ( 1 , 3 ) ; mwIndex subs [ 2 ] , offset ; { static const char_T * blockType [ 1 ] = { "S-Function" , } ; static const char_T * blockPath [ 1 ] = { "bucket_fft/From Multimedia File" , } ; static const int reason [ 1 ] = { 1 , } ; for ( subs [ 0 ] = 0 ; subs [ 0 ] < 1 ; ++ ( subs [ 0 ] ) ) { subs [ 1 ] = 0 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockType [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 1 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateString ( blockPath [ subs [ 0 ] ] ) ) ; subs [ 1 ] = 2 ; offset = mxCalcSingleSubscript ( data , 2 , subs ) ; mxSetCell ( data , offset , mxCreateDoubleScalar ( ( real_T ) reason [ subs [ 0 ] ] ) ) ; } } return data ; } void MdlInitializeSizes ( void ) { ssSetNumContStates ( rtS , 0 ) ; ssSetNumY ( rtS , 0 ) ; ssSetNumU ( rtS , 0 ) ; ssSetDirectFeedThrough ( rtS , 0 ) ; ssSetNumSampleTimes ( rtS , 3 ) ; ssSetNumBlocks ( rtS , 21 ) ; ssSetNumBlockIO ( rtS , 11 ) ; ssSetNumBlockParams ( rtS , 9 ) ; } void MdlInitializeSampleTimes ( void ) { ssSetSampleTime ( rtS , 0 , 0.0 ) ; ssSetSampleTime ( rtS , 1 , 0.023219954648526078 ) ; ssSetSampleTime ( rtS , 2 , 0.44897959183673469 ) ; ssSetOffsetTime ( rtS , 0 , 1.0 ) ; ssSetOffsetTime ( rtS , 1 , 0.0 ) ; ssSetOffsetTime ( rtS , 2 , 0.0 ) ; } void raccel_set_checksum ( ) { ssSetChecksumVal ( rtS , 0 , 3841060151U ) ; ssSetChecksumVal ( rtS , 1 , 3132833807U ) ; ssSetChecksumVal ( rtS , 2 , 1446850906U ) ; ssSetChecksumVal ( rtS , 3 , 3013277858U ) ; }
#if defined(_MSC_VER)
#pragma optimize( "", off )
#endif
SimStruct * raccel_register_model ( ssExecutionInfo * executionInfo ) {
static struct _ssMdlInfo mdlInfo ; static struct _ssBlkInfo2 blkInfo2 ;
static struct _ssBlkInfoSLSize blkInfoSLSize ; rt_modelMapInfoPtr = & ( rt_dataMapInfo . mmi ) ; executionInfo -> gblObjects_ . numToFiles = 0 ; executionInfo -> gblObjects_ . numFrFiles = 0 ; executionInfo -> gblObjects_ . numFrWksBlocks = 0 ; executionInfo -> gblObjects_ . numModelInputs = 0 ; executionInfo -> gblObjects_ . numRootInportBlks = 0 ; executionInfo -> gblObjects_ . inportDataTypeIdx = NULL ; executionInfo -> gblObjects_ . inportDims = NULL ; executionInfo -> gblObjects_ . inportComplex = NULL ; executionInfo -> gblObjects_ . inportInterpoFlag = NULL ; executionInfo -> gblObjects_ . inportContinuous = NULL ; ( void ) memset ( ( char_T * ) rtS , 0 , sizeof ( SimStruct ) ) ; ( void ) memset ( ( char_T * ) & mdlInfo , 0 , sizeof ( struct _ssMdlInfo ) ) ; ( void ) memset ( ( char_T * ) & blkInfo2 , 0 , sizeof ( struct _ssBlkInfo2 ) ) ; ( void ) memset ( ( char_T * ) & blkInfoSLSize , 0 , sizeof ( struct _ssBlkInfoSLSize ) ) ; ssSetBlkInfo2Ptr ( rtS , & blkInfo2 ) ; ssSetBlkInfoSLSizePtr ( rtS , & blkInfoSLSize ) ; ssSetMdlInfoPtr ( rtS , & mdlInfo ) ; ssSetExecutionInfo ( rtS , executionInfo ) ; slsaAllocOPModelData ( rtS ) ; { static time_T mdlPeriod [ NSAMPLE_TIMES ] ; static time_T mdlOffset [ NSAMPLE_TIMES ] ; static time_T mdlTaskTimes [ NSAMPLE_TIMES ] ; static int_T mdlTsMap [ NSAMPLE_TIMES ] ; static int_T mdlSampleHits [ NSAMPLE_TIMES ] ; static boolean_T mdlTNextWasAdjustedPtr [ NSAMPLE_TIMES ] ; static int_T mdlPerTaskSampleHits [ NSAMPLE_TIMES * NSAMPLE_TIMES ] ; static time_T mdlTimeOfNextSampleHit [ NSAMPLE_TIMES ] ; { int_T i ; for ( i = 0 ; i < NSAMPLE_TIMES ; i ++ ) { mdlPeriod [ i ] = 0.0 ; mdlOffset [ i ] = 0.0 ; mdlTaskTimes [ i ] = 0.0 ; mdlTsMap [ i ] = i ; mdlSampleHits [ i ] = 1 ; } } ssSetSampleTimePtr ( rtS , & mdlPeriod [ 0 ] ) ; ssSetOffsetTimePtr ( rtS , & mdlOffset [ 0 ] ) ; ssSetSampleTimeTaskIDPtr ( rtS , & mdlTsMap [ 0 ] ) ; ssSetTPtr ( rtS , & mdlTaskTimes [ 0 ] ) ; ssSetSampleHitPtr ( rtS , & mdlSampleHits [ 0 ] ) ; ssSetTNextWasAdjustedPtr ( rtS , & mdlTNextWasAdjustedPtr [ 0 ] ) ; ssSetPerTaskSampleHitsPtr ( rtS , & mdlPerTaskSampleHits [ 0 ] ) ; ssSetTimeOfNextSampleHitPtr ( rtS , & mdlTimeOfNextSampleHit [ 0 ] ) ; } ssSetSolverMode ( rtS , SOLVER_MODE_SINGLETASKING ) ; { ssSetBlockIO ( rtS , ( ( void * ) & rtB ) ) ; ( void ) memset ( ( ( void * ) & rtB ) , 0 , sizeof ( B ) ) ; } { void * dwork = ( void * ) & rtDW ; ssSetRootDWork ( rtS , dwork ) ; ( void ) memset ( dwork , 0 , sizeof ( DW ) ) ; } { static DataTypeTransInfo dtInfo ; ( void ) memset ( ( char_T * ) & dtInfo , 0 , sizeof ( dtInfo ) ) ; ssSetModelMappingInfo ( rtS , & dtInfo ) ; dtInfo . numDataTypes = 24 ; dtInfo . dataTypeSizes = & rtDataTypeSizes [ 0 ] ; dtInfo . dataTypeNames = & rtDataTypeNames [ 0 ] ; dtInfo . BTransTable = & rtBTransTable ; dtInfo . PTransTable = & rtPTransTable ; dtInfo . dataTypeInfoTable = rtDataTypeInfoTable ; } bucket_fft_InitializeDataMapInfo ( ) ; ssSetIsRapidAcceleratorActive ( rtS , true ) ; ssSetRootSS ( rtS , rtS ) ; ssSetVersion ( rtS , SIMSTRUCT_VERSION_LEVEL2 ) ; ssSetModelName ( rtS , "bucket_fft" ) ; ssSetPath ( rtS , "bucket_fft" ) ; ssSetTStart ( rtS , 0.0 ) ; ssSetTFinal ( rtS , INFINITY ) ; { static RTWLogInfo rt_DataLoggingInfo ; rt_DataLoggingInfo . loggingInterval = ( NULL ) ; ssSetRTWLogInfo ( rtS , & rt_DataLoggingInfo ) ; } { { static int_T rt_LoggedStateWidths [ ] = { 40000 , 1 , 1 , 1 } ; static int_T rt_LoggedStateNumDimensions [ ] = { 1 , 1 , 1 , 1 } ; static int_T rt_LoggedStateDimensions [ ] = { 40000 , 1 , 1 , 1 } ; static boolean_T rt_LoggedStateIsVarDims [ ] = { 0 , 0 , 0 , 0 } ; static BuiltInDTypeId rt_LoggedStateDataTypeIds [ ] = { SS_DOUBLE , SS_INT32 , SS_INT32 , SS_INT32 } ; static int_T rt_LoggedStateComplexSignals [ ] = { 0 , 0 , 0 , 0 } ; static RTWPreprocessingFcnPtr rt_LoggingStatePreprocessingFcnPtrs [ ] = { ( NULL ) , ( NULL ) , ( NULL ) , ( NULL ) } ; static const char_T * rt_LoggedStateLabels [ ] = { "CircBuf" , "inBufPtrIdx" , "outBufPtrIdx" , "bufferLength" } ; static const char_T * rt_LoggedStateBlockNames [ ] = { "bucket_fft/Buffer" , "bucket_fft/Buffer" , "bucket_fft/Buffer" , "bucket_fft/Buffer" } ; static const char_T * rt_LoggedStateNames [ ] = { "CircBuf" , "inBufPtrIdx" , "outBufPtrIdx" , "bufferLength" } ; static boolean_T rt_LoggedStateCrossMdlRef [ ] = { 0 , 0 , 0 , 0 } ; static RTWLogDataTypeConvert rt_RTWLogDataTypeConvert [ ] = { { 0 , SS_DOUBLE , SS_DOUBLE , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_INT32 , SS_INT32 , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_INT32 , SS_INT32 , 0 , 0 , 0 , 1.0 , 0 , 0.0 } , { 0 , SS_INT32 , SS_INT32 , 0 , 0 , 0 , 1.0 , 0 , 0.0 } } ; static int_T rt_LoggedStateIdxList [ ] = { 0 , 5 , 6 , 7 } ; static RTWLogSignalInfo rt_LoggedStateSignalInfo = { 4 , rt_LoggedStateWidths , rt_LoggedStateNumDimensions , rt_LoggedStateDimensions , rt_LoggedStateIsVarDims , ( NULL ) , ( NULL ) , rt_LoggedStateDataTypeIds , rt_LoggedStateComplexSignals , ( NULL ) , rt_LoggingStatePreprocessingFcnPtrs , { rt_LoggedStateLabels } , ( NULL ) , ( NULL ) , ( NULL ) , { rt_LoggedStateBlockNames } , { rt_LoggedStateNames } , rt_LoggedStateCrossMdlRef , rt_RTWLogDataTypeConvert , rt_LoggedStateIdxList } ; static void * rt_LoggedStateSignalPtrs [ 4 ] ; rtliSetLogXSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( LogSignalPtrsType ) rt_LoggedStateSignalPtrs ) ; rtliSetLogXSignalInfo ( ssGetRTWLogInfo ( rtS ) , & rt_LoggedStateSignalInfo ) ; rt_LoggedStateSignalPtrs [ 0 ] = ( void * ) rtDW . eevlbptizq ; rt_LoggedStateSignalPtrs [ 1 ] = ( void * ) & rtDW . ksb220rab2 ; rt_LoggedStateSignalPtrs [ 2 ] = ( void * ) & rtDW . aiwfpkwj3j ; rt_LoggedStateSignalPtrs [ 3 ] = ( void * ) & rtDW . dhaotaxhrp ; } rtliSetLogT ( ssGetRTWLogInfo ( rtS ) , "tout" ) ; rtliSetLogX ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogXFinal ( ssGetRTWLogInfo ( rtS ) , "xFinal" ) ; rtliSetLogVarNameModifier ( ssGetRTWLogInfo ( rtS ) , "none" ) ; rtliSetLogFormat ( ssGetRTWLogInfo ( rtS ) , 4 ) ; rtliSetLogMaxRows ( ssGetRTWLogInfo ( rtS ) , 0 ) ; rtliSetLogDecimation ( ssGetRTWLogInfo ( rtS ) , 1 ) ; rtliSetLogY ( ssGetRTWLogInfo ( rtS ) , "" ) ; rtliSetLogYSignalInfo ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; rtliSetLogYSignalPtrs ( ssGetRTWLogInfo ( rtS ) , ( NULL ) ) ; } { static ssSolverInfo slvrInfo ; ssSetStepSize ( rtS , 0.023219954648526078 ) ; ssSetMinStepSize ( rtS , 0.0 ) ; ssSetMaxNumMinSteps ( rtS , - 1 ) ; ssSetMinStepViolatedError ( rtS , 0 ) ; ssSetMaxStepSize ( rtS , 0.023219954648526078 ) ; ssSetSolverMaxOrder ( rtS , - 1 ) ; ssSetSolverRefineFactor ( rtS , 1 ) ; ssSetOutputTimes ( rtS , ( NULL ) ) ; ssSetNumOutputTimes ( rtS , 0 ) ; ssSetOutputTimesOnly ( rtS , 0 ) ; ssSetOutputTimesIndex ( rtS , 0 ) ; ssSetZCCacheNeedsReset ( rtS , 0 ) ; ssSetDerivCacheNeedsReset ( rtS , 0 ) ; ssSetNumNonContDerivSigInfos ( rtS , 0 ) ; ssSetNonContDerivSigInfos ( rtS , ( NULL ) ) ; ssSetSolverInfo ( rtS , & slvrInfo ) ; ssSetSolverName ( rtS , "VariableStepDiscrete" ) ; ssSetVariableStepSolver ( rtS , 1 ) ; ssSetSolverConsistencyChecking ( rtS , 0 ) ; ssSetSolverAdaptiveZcDetection ( rtS , 0 ) ; ssSetSolverRobustResetMethod ( rtS , 0 ) ; ssSetSolverStateProjection ( rtS , 0 ) ; ssSetSolverMassMatrixType ( rtS , ( ssMatrixType ) 0 ) ; ssSetSolverMassMatrixNzMax ( rtS , 0 ) ; ssSetModelOutputs ( rtS , MdlOutputs ) ; ssSetModelUpdate ( rtS , MdlUpdate ) ; ssSetTNextTid ( rtS , INT_MIN ) ; ssSetTNext ( rtS , rtMinusInf ) ; ssSetSolverNeedsReset ( rtS ) ; ssSetNumNonsampledZCs ( rtS , 0 ) ; } ssSetChecksumVal ( rtS , 0 , 3841060151U ) ; ssSetChecksumVal ( rtS , 1 , 3132833807U ) ; ssSetChecksumVal ( rtS , 2 , 1446850906U ) ; ssSetChecksumVal ( rtS , 3 , 3013277858U ) ; { static const sysRanDType rtAlwaysEnabled = SUBSYS_RAN_BC_ENABLE ; static RTWExtModeInfo rt_ExtModeInfo ; static const sysRanDType * systemRan [ 6 ] ; gblRTWExtModeInfo = & rt_ExtModeInfo ; ssSetRTWExtModeInfo ( rtS , & rt_ExtModeInfo ) ; rteiSetSubSystemActiveVectorAddresses ( & rt_ExtModeInfo , systemRan ) ; systemRan [ 0 ] = & rtAlwaysEnabled ; systemRan [ 1 ] = & rtAlwaysEnabled ; systemRan [ 2 ] = & rtAlwaysEnabled ; systemRan [ 3 ] = & rtAlwaysEnabled ; systemRan [ 4 ] = & rtAlwaysEnabled ; systemRan [ 5 ] = & rtAlwaysEnabled ; rteiSetModelMappingInfoPtr ( ssGetRTWExtModeInfo ( rtS ) , & ssGetModelMappingInfo ( rtS ) ) ; rteiSetChecksumsPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetChecksums ( rtS ) ) ; rteiSetTPtr ( ssGetRTWExtModeInfo ( rtS ) , ssGetTPtr ( rtS ) ) ; } slsaDisallowedBlocksForSimTargetOP ( rtS , mr_bucket_fft_GetSimStateDisallowedBlocks ) ; slsaGetWorkFcnForSimTargetOP ( rtS , mr_bucket_fft_GetDWork ) ; slsaSetWorkFcnForSimTargetOP ( rtS , mr_bucket_fft_SetDWork ) ; rt_RapidReadMatFileAndUpdateParams ( rtS ) ; if ( ssGetErrorStatus ( rtS ) ) { return rtS ; } executionInfo -> simulationOptions_ . stateSaveName_ = rtliGetLogX ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . finalStateName_ = rtliGetLogXFinal ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . outputSaveName_ = rtliGetLogY ( ssGetRTWLogInfo ( rtS ) ) ; executionInfo -> simulationOptions_ . inputTimeTolerance_ = 0.0 ; return rtS ; }
#if defined(_MSC_VER)
#pragma optimize( "", on )
#endif
void MdlOutputsParameterSampleTime ( int_T tid ) { MdlOutputsTID3 ( tid ) ; }
